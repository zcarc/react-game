
1-5.
    바벨은 문법만 최신문법으로 변환해준다.
    기존에 바벨만 추가해서 자바스크립트로 변환한 상태에서
    최신 객체나 메서드를 사용하고 싶다면 바벨 폴리픽이라는 것을 추가해야한다.


2-3.
    lecture>npm init
    lecture>npm i react react-dom
    lecture>npm i -D webpack webpack-cli

    -D: 개발할 때만 사용한다는 의미
        실제 서비스 할 때는 webpack이 필요없다.

    devDependencies 에는 개발할 때만 사용하고,
    dependencies 에는 실제 서비스할 때 사용한다.

2-5.
    lecture>webpack 명령어 입력시 명령어를 찾을 수 없다고 에러가 뜨는 경우 해결방법
        1. package.json 의 scripts에 "dev": "webpack"으로 명시하는 방법
            npm run dev 치는 순간 webpack 실행

        2. npx webpack 명령어로 실행


    바벨 설치 (배포할 때는 안쓰이고 개발할 때만 쓰인다.)
    npm 다음에 패키지를 여러개 설치하는데 한칸 띄는 의미는 '&'의 의미로 'and'의 의미이다.
    @bable/core: 바벨 코어 파일이 내장되어 있다.(기본 파일)
    @babel/preset-env: 브라우저에 맞게 알아서 최신문법들을 해석할 수 있는 문법(예전 문법)으로 변환해준다.
    @bable/preset-react: jsx를 지원해준다.
    babel-loader: babel과 webpack을 연결해준다. (webpack이 js 파일들에 대해 babel을 실행하도록 만들어준다.)
    lecture>npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader

    lecture>npm i -D @babel/plugin-proposal-class-properties


2-6.
    01_GuGuDan>npm init
    01_GuGuDan>npm i react react-dom
    01_GuGuDan>npm i -D webpack webpack-cli
    01_GuGuDan>npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader @babel/plugin-proposal-class-properties

    * IE에서 넣어주면 좋은 메타 태그
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

2-7.
    plugins의 모음들이 presets
    @babel/preset-env 안에 많은 플러그인들이 포함되어 있다.
    예전 브라우저들을 바벨이 호환될 수 있도록 하는 것인데
    특정 버전의 브라우저만 호환되게 하고 싶을 때 옵션을 줄 수 있다.
    options: {
                    presets: [
                        ['@babel/preset-env', {
                            targets:{
                                browsers: ['last 2 chrome versions']
                            }
                        }], '@babel/preset-react'],
                    plugins: []
                }
    이렇게 작성하면 크롬 최신버전과 그 전 버전까지 호환되게 설정하고 익스플로러는 호환되지 않는다.
    회사에서 지원하고자 하는 브라우저만 적어주면 더 좋다.
    전부 다 지원하게 만들면 바벨에서 하는 일이 많기 때문에 점점 느려진다.

    브라우저 목록을 볼 수 있는 주소
    https://github.com/browserslist/browserslist

    이렇게 작성하면 한국에서 점유율이 5% 이상인 브라우저들을 지원한다는 의미이다.
    browsers: ['> 5% in KR']

    "debug: true"는 개발할 때 사용할 수도 있다.
    options: {
                        presets: [
                            ['@babel/preset-env', {
                                targets:{
                                    browsers: ['> 5% in KR', 'last 2 chrome versions']
                                },
                                debug: true,
                            }], '@babel/preset-react'],
                        plugins: []
                    }


2-9.

    02_WordRelay>npm i -D webpack-dev-server
    02_WordRelay>npm i -D react-hot-loader

    webpack-dev-server: "webpack.config.js"를 읽어서 빌드를 해주고 서버로 유지를 시켜준다.
    react-hot-loader: 코드 수정이 발생하면 실시간으로 반영된다.

    * 강의에서는 react-hot-loader를 사용하라고 하지만 사용하지 않아도 현재 반영은 된다.

    webpack.config.js는 수정하면 바로 반영되지 않아서 webpack을 다시 실행해야한다.

    webpack-dev-server가 감지하는 것은 클라이언트에서 불러온 애들만 자동으로 업데이트 해주고
    webpack.config.js에서는 바뀐것을 감지하지 못한다.



2-10.

    리액트 버전 업으로 react-hot-loader는 추가 설정이 필요하다.
    "webpack.config.js"의 "rules"에 아래 부분을 추가해야함.
            {
                test: /\.(js|jsx)$/,
                use: 'react-hot-loader/webpack',
                include: /node_modules/
            }

    클래스 메서드들은 더 이상 클래스가 아니기 때문에 Hooks 함수 내의 메서드들은
    const, let 타입으로 변수로 선언을 해줘야한다.

    localhost:8080으로 들어가서 실행해보면 두가지가 뜬다.
    HMR: Hot module reload
    WDS: Web pack dev server



3-1. import와 require 비교

    require(''): 노드의 모듈 시스템
    import: ES2015 문법

    import는 정적 임포트, require는 동적 임포트라는 차이가 있다.
    import는 항상 파일 상단에, require는 파일 아무데서나 쓸 수 있다.

    class NumberBaseball extends Component{}
    module.exports = NumberBaseball;
    const numberBaseball = require('./NumberBaseball');

    변수 numberBaseball는 클래스가 된다.
    require()와 import는 호환이 된다.


    import React from 'react';
    import ReactDOM from 'react-dom');

    import WordRelay from = require('./WordRelay_Hooks');
    import {hot} from 'react-hot-loader/root';

    const {Hot} = hot(WordRelay);

    exports 되는 게 객체나 배열이면 구조 분해할 수 있다.


    NumberBaseball.jsx
        import React, {Component} from 'react';

        class NumberBaseball extends Component {
        }

        exports const hello = 'hello'; // default 가 아닌 것들은 import { hello };
        exports default NumberBaseball; // 가져올 때 import NumberBaseball

    default는 exports를 한번만 쓸 수 있고 나머지들은 변수명만 겹치지 않으면 계속 만들 수 있다.

    엄밀히 따지면
    "exports default"와 "module.exports"는 다르다.
    하지만 호환이 된다라고만 알고 있으면 된다.

    노드 모듈 시스템에서
    module.ports = { hello: 'a' };
    exports.hello = 'a';
    위 두개는 서로 같다.

    그래서 "import", "exports default"는 ES2015 문법이고
    "require()", "exports.module"은 노드의 모듈 문법이다.

    노드의 모듈 문법은 common.js 라고 한다.

    노드에서는 기본적으로 노드 모듈 문법만 지원한다.
    그래서 import를 쓰면 에러가 난다.
    근데 다른 코드들 중 import를  쓰는데도 동작하는 이유는
    바벨이 import도 require로 바꿔준다.
    노드에서는 노드 문법쓰고 리액트에서는 ES2015 문법 쓴다고 생각하면 된다.

    주의할점은 webpack.config.js에서는 ES2015 문법을 사용하면 에러가 발생해서
    require()을 사용하는 노드 문법을 사용해야한다.
    그래서 client의 jsx 파일들은 웹팩이 다 바꿔주기 때문에 ES2015 문법을 사용해도 상관없다.


3-9. React Devtools

    크롬 확장프로그램이고 디버깅할 때 좀 더 편하다.



3-11. PureComponent와 React.memo

    PureComponent : shouldComponentUpdate()가 이미 구현되어 있는 객체
        PureComponent의 문제점은 객체나 배열이 참조 관계일 때 참조된 state를 그대로 넣으면 참조관계가 true여서
        PureComponent가 알아차리지 못한다. 그래서 state가 바뀌지 않은 것으로 판단되어 redering을 하지 않는다.